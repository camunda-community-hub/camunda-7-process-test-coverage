{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"This Camunda Platform 7 and Platform 8 community extension visualises test process paths and checks your process model coverage ratio. Running typical JUnit tests now leaves html files in your build output. Just open one and check yourself what your test did: Highlights # Visually verify the paths covered by individual tests methods and whole test classes Visually check gateway expressions and transaction borders ( save points ) used by your process Calculate and verify the nodes ( and sequence flow) coverage ratio reached by tests methods and classes. Quick Start # If you just want to start using the library, please consult our Getting Started guide. User Guide # If you have any questions regarding configuration and usage, please conduct the User Guide . Contribution # If you want to contribute to this project, feel free to do so. Start with Contributing guide .","title":"Home"},{"location":"index.html#highlights","text":"Visually verify the paths covered by individual tests methods and whole test classes Visually check gateway expressions and transaction borders ( save points ) used by your process Calculate and verify the nodes ( and sequence flow) coverage ratio reached by tests methods and classes.","title":"Highlights"},{"location":"index.html#quick-start","text":"If you just want to start using the library, please consult our Getting Started guide.","title":"Quick Start"},{"location":"index.html#user-guide","text":"If you have any questions regarding configuration and usage, please conduct the User Guide .","title":"User Guide"},{"location":"index.html#contribution","text":"If you want to contribute to this project, feel free to do so. Start with Contributing guide .","title":"Contribution"},{"location":"getting-started.html","text":"Install Dependency # The library supports multiple execution platforms for the test and multiple process engines, so we supply different artifacts which you need to add to your project dependencies: Please define the version of the library using properties like this: <properties> <camunda-process-test-coverage.version> 2.0.1-SNAPSHOT </camunda-process-test-coverage.version> </properties> JUnit4 (only Platform 7) # <dependency> <groupId> org.camunda.community.process_test_coverage </groupId> <artifactId> camunda-process-test-coverage-junit4-platform-7 </artifactId> <version> ${camunda-process-test-coverage.version} </version> <scope> test </scope> </dependency> JUnit5 (Platform 7 or Platform 8) # <dependency> <groupId> org.camunda.community.process_test_coverage </groupId> <artifactId> camunda-process-test-coverage-junit5-platform-7 </artifactId> <!-- <artifactId>camunda-process-test-coverage-junit5-platform-8</artifactId> --> <version> ${camunda-process-test-coverage.version} </version> <scope> test </scope> </dependency> Spring-Testing (Platform 7 or Platform 8) # <dependency> <groupId> org.camunda.community.process_test_coverage </groupId> <artifactId> camunda-process-test-coverage-spring-test-platform-7 </artifactId> <!-- <artifactId>camunda-process-test-coverage-spring-test-platform-8</artifactId> --> <version> ${camunda-process-test-coverage.version} </version> <scope> test </scope> </dependency> Spring-Testing with starter (Platform 7 or Platform 8) # <dependency> <groupId> org.camunda.community.process_test_coverage </groupId> <artifactId> camunda-process-test-coverage-starter-platform-7 </artifactId> <!-- <artifactId>camunda-process-test-coverage-starter-platform-8</artifactId> --> <version> ${camunda-process-test-coverage.version} </version> <scope> test </scope> </dependency> With the starter the further configuration steps are not needed anymore, as everything is auto-configured. This means you have to explicitly exclude all test classes and test methods, that should not be included in the test coverage. Configuration # Use the ProcessCoverageInMemProcessEngineConfiguration , e.g. in your camunda.cfg.xml (only needed for Platform 7) JUnit4 and JUnit5 # <bean id= \"processEngineConfiguration\" class= \"org.camunda.community.process_test_coverage.engine.platform7.ProcessCoverageInMemProcessEngineConfiguration\" > ... </bean> Spring-Testing # Import test configuration to enable coverage in process engine. @Import ( ProcessEngineCoverageConfiguration . class ) Usage # Wire the process engine in your JUnit test: JUnit4 # Use the TestCoverageProcessEngineRule as your process engine JUnit rule @Rule @ClassRule public static ProcessEngineRule rule = TestCoverageProcessEngineRuleBuilder . create (). build (); JUnit5 # Use the ProcessEngineCoverageExtension as your process engine JUnit extension (available for Platform 7 and Platform 8) Either use @ExtendWith Java @ExtendWith ( ProcessEngineCoverageExtension . class ) public class MyProcessTest Kotlin @ExtendWith ( ProcessEngineCoverageExtension :: class ) class MyProcessTest or @RegisterExtension If you register the extension on a non-static field, no class coverage and therefore no report will be generated. This is due to the fact, that an instance of the extension will be created per test method. The extension provides a Builder for programmatic creation, which takes either a path to a configuration resource, a process engine configuration or if nothing is passed uses the default configuration resources path ( camunda.cfg.xml ). The process engine configuration needs to be configured for test coverage. So use either the provided ProcessCoverageInMemProcessEngineConfiguration , SpringProcessWithCoverageEngineConfiguration or initialize the configuration with ProcessCoverageConfigurator.initializeProcessCoverageExtensions(configuration) . In Java it looks like this: @RegisterExtension static ProcessEngineCoverageExtension extension = ProcessEngineCoverageExtension . builder (). assertClassCoverageAtLeast ( 0.9 ). build (); If you prefer Kotlin, this is the way to go: companion object { @JvmField @RegisterExtension var extension : ProcessEngineCoverageExtension = ProcessEngineCoverageExtension . builder ( ProcessCoverageInMemProcessEngineConfiguration ()) . assertClassCoverageAtLeast ( 1.0 ). build () } Spring-Testing # TestExecutionListener is automatically registered. You can exclude test methods or classes from the coverage by annotating them like this @ExcludeFromProcessCoverage public void testWithoutCoverage () {} Running the tests # Running your JUnit tests now leaves html files for individual test methods as well as whole test classes in your project's target/process-test-coverage folder. Just open one, check yourself - and have fun with your process tests! :smile: Aggregating results # Normally the results are written for each class under test. For aggregation of the results, there is a maven plugin to do the job. This can be done differently depending on your needs. Aggregating reports in one maven module # If you just want to aggregate all reports in one maven module, the plugin can be defined in the POM under the build -> plugins section. <build> <plugins> <plugin> <groupId> org.camunda.community.process_test_coverage </groupId> <artifactId> camunda-process-test-coverage-report-aggregator-maven-plugin </artifactId> <executions> <execution> <id> aggregate-reports </id> <goals> <goal> aggregate </goal> </goals> </execution> </executions> </plugin> </plugins> </build> This will activate the plugin in the correct lifecycle and generate an aggregated report in the directory target/process_test_coverage/all (if not otherwise configured). Aggregating reports of multiple modules in reactor # The plugin will try to collect all reports for the modules in the current reactor. For an example configuration see the pom.xml in the examples directory. Please note, that the plugin needs to run after the tests are run for all modules, therefore the plugin cannot be added to the plugins section in this use case. You can still configure the plugin in the pluginManagement section. <build> <pluginManagement> <plugins> <plugin> <groupId> org.camunda.community.process_test_coverage </groupId> <artifactId> camunda-process-test-coverage-report-aggregator-maven-plugin </artifactId> <version> x.y.z </version> </plugin> </plugins> </pluginManagement> </build> It can then be invoked by calling mvn camunda-process-test-coverage-report-aggregator:aggregate . Usage as a reporting plugin # The plugin can also be used in the site generation. For this to work, the same conditions hold as before. The configuration for this use case looks like this: <reporting> <plugins> <plugin> <groupId> org.camunda.community.process_test_coverage </groupId> <artifactId> camunda-process-test-coverage-report-aggregator-maven-plugin </artifactId> <version> x.y.z </version> </plugin> </plugins> </reporting>","title":"Getting started"},{"location":"getting-started.html#install-dependency","text":"The library supports multiple execution platforms for the test and multiple process engines, so we supply different artifacts which you need to add to your project dependencies: Please define the version of the library using properties like this: <properties> <camunda-process-test-coverage.version> 2.0.1-SNAPSHOT </camunda-process-test-coverage.version> </properties>","title":"Install Dependency"},{"location":"getting-started.html#junit4-only-platform-7","text":"<dependency> <groupId> org.camunda.community.process_test_coverage </groupId> <artifactId> camunda-process-test-coverage-junit4-platform-7 </artifactId> <version> ${camunda-process-test-coverage.version} </version> <scope> test </scope> </dependency>","title":"JUnit4 (only Platform 7)"},{"location":"getting-started.html#junit5-platform-7-or-platform-8","text":"<dependency> <groupId> org.camunda.community.process_test_coverage </groupId> <artifactId> camunda-process-test-coverage-junit5-platform-7 </artifactId> <!-- <artifactId>camunda-process-test-coverage-junit5-platform-8</artifactId> --> <version> ${camunda-process-test-coverage.version} </version> <scope> test </scope> </dependency>","title":"JUnit5 (Platform 7 or Platform 8)"},{"location":"getting-started.html#spring-testing-platform-7-or-platform-8","text":"<dependency> <groupId> org.camunda.community.process_test_coverage </groupId> <artifactId> camunda-process-test-coverage-spring-test-platform-7 </artifactId> <!-- <artifactId>camunda-process-test-coverage-spring-test-platform-8</artifactId> --> <version> ${camunda-process-test-coverage.version} </version> <scope> test </scope> </dependency>","title":"Spring-Testing (Platform 7 or Platform 8)"},{"location":"getting-started.html#spring-testing-with-starter-platform-7-or-platform-8","text":"<dependency> <groupId> org.camunda.community.process_test_coverage </groupId> <artifactId> camunda-process-test-coverage-starter-platform-7 </artifactId> <!-- <artifactId>camunda-process-test-coverage-starter-platform-8</artifactId> --> <version> ${camunda-process-test-coverage.version} </version> <scope> test </scope> </dependency> With the starter the further configuration steps are not needed anymore, as everything is auto-configured. This means you have to explicitly exclude all test classes and test methods, that should not be included in the test coverage.","title":"Spring-Testing with starter (Platform 7 or Platform 8)"},{"location":"getting-started.html#configuration","text":"Use the ProcessCoverageInMemProcessEngineConfiguration , e.g. in your camunda.cfg.xml (only needed for Platform 7)","title":"Configuration"},{"location":"getting-started.html#junit4-and-junit5","text":"<bean id= \"processEngineConfiguration\" class= \"org.camunda.community.process_test_coverage.engine.platform7.ProcessCoverageInMemProcessEngineConfiguration\" > ... </bean>","title":"JUnit4 and JUnit5"},{"location":"getting-started.html#spring-testing","text":"Import test configuration to enable coverage in process engine. @Import ( ProcessEngineCoverageConfiguration . class )","title":"Spring-Testing"},{"location":"getting-started.html#usage","text":"Wire the process engine in your JUnit test:","title":"Usage"},{"location":"getting-started.html#junit4","text":"Use the TestCoverageProcessEngineRule as your process engine JUnit rule @Rule @ClassRule public static ProcessEngineRule rule = TestCoverageProcessEngineRuleBuilder . create (). build ();","title":"JUnit4"},{"location":"getting-started.html#junit5","text":"Use the ProcessEngineCoverageExtension as your process engine JUnit extension (available for Platform 7 and Platform 8) Either use @ExtendWith Java @ExtendWith ( ProcessEngineCoverageExtension . class ) public class MyProcessTest Kotlin @ExtendWith ( ProcessEngineCoverageExtension :: class ) class MyProcessTest or @RegisterExtension If you register the extension on a non-static field, no class coverage and therefore no report will be generated. This is due to the fact, that an instance of the extension will be created per test method. The extension provides a Builder for programmatic creation, which takes either a path to a configuration resource, a process engine configuration or if nothing is passed uses the default configuration resources path ( camunda.cfg.xml ). The process engine configuration needs to be configured for test coverage. So use either the provided ProcessCoverageInMemProcessEngineConfiguration , SpringProcessWithCoverageEngineConfiguration or initialize the configuration with ProcessCoverageConfigurator.initializeProcessCoverageExtensions(configuration) . In Java it looks like this: @RegisterExtension static ProcessEngineCoverageExtension extension = ProcessEngineCoverageExtension . builder (). assertClassCoverageAtLeast ( 0.9 ). build (); If you prefer Kotlin, this is the way to go: companion object { @JvmField @RegisterExtension var extension : ProcessEngineCoverageExtension = ProcessEngineCoverageExtension . builder ( ProcessCoverageInMemProcessEngineConfiguration ()) . assertClassCoverageAtLeast ( 1.0 ). build () }","title":"JUnit5"},{"location":"getting-started.html#spring-testing_1","text":"TestExecutionListener is automatically registered. You can exclude test methods or classes from the coverage by annotating them like this @ExcludeFromProcessCoverage public void testWithoutCoverage () {}","title":"Spring-Testing"},{"location":"getting-started.html#running-the-tests","text":"Running your JUnit tests now leaves html files for individual test methods as well as whole test classes in your project's target/process-test-coverage folder. Just open one, check yourself - and have fun with your process tests! :smile:","title":"Running the tests"},{"location":"getting-started.html#aggregating-results","text":"Normally the results are written for each class under test. For aggregation of the results, there is a maven plugin to do the job. This can be done differently depending on your needs.","title":"Aggregating results"},{"location":"getting-started.html#aggregating-reports-in-one-maven-module","text":"If you just want to aggregate all reports in one maven module, the plugin can be defined in the POM under the build -> plugins section. <build> <plugins> <plugin> <groupId> org.camunda.community.process_test_coverage </groupId> <artifactId> camunda-process-test-coverage-report-aggregator-maven-plugin </artifactId> <executions> <execution> <id> aggregate-reports </id> <goals> <goal> aggregate </goal> </goals> </execution> </executions> </plugin> </plugins> </build> This will activate the plugin in the correct lifecycle and generate an aggregated report in the directory target/process_test_coverage/all (if not otherwise configured).","title":"Aggregating reports in one maven module"},{"location":"getting-started.html#aggregating-reports-of-multiple-modules-in-reactor","text":"The plugin will try to collect all reports for the modules in the current reactor. For an example configuration see the pom.xml in the examples directory. Please note, that the plugin needs to run after the tests are run for all modules, therefore the plugin cannot be added to the plugins section in this use case. You can still configure the plugin in the pluginManagement section. <build> <pluginManagement> <plugins> <plugin> <groupId> org.camunda.community.process_test_coverage </groupId> <artifactId> camunda-process-test-coverage-report-aggregator-maven-plugin </artifactId> <version> x.y.z </version> </plugin> </plugins> </pluginManagement> </build> It can then be invoked by calling mvn camunda-process-test-coverage-report-aggregator:aggregate .","title":"Aggregating reports of multiple modules in reactor"},{"location":"getting-started.html#usage-as-a-reporting-plugin","text":"The plugin can also be used in the site generation. For this to work, the same conditions hold as before. The configuration for this use case looks like this: <reporting> <plugins> <plugin> <groupId> org.camunda.community.process_test_coverage </groupId> <artifactId> camunda-process-test-coverage-report-aggregator-maven-plugin </artifactId> <version> x.y.z </version> </plugin> </plugins> </reporting>","title":"Usage as a reporting plugin"},{"location":"developer-guide/contribution.html","text":"How to Contribute # We'd love you to contribute to this project by filing bugs, helping others on the issue tracker , and by contributing features/bug fixes through pull requests. Read more on how to get the project up and running . Creating Issues # Please use our issue tracker for project communication. When using the issue tracker: Be descriptive when creating an issue (what, where, when and how does a problem pop up)? Attach steps to reproduce (if applicable) Attach code samples, configuration options or stack traces that may indicate a problem Be helpful and respect others when commenting Create a pull request if you would like to have an in-depth discussion about some piece of code. Setting Up the Project Locally # The project is build using Maven 3 as build tool. To build the project by yourself, go to your cmd line and enter mvn clean install on the root of the checked out project. git clone https://github.com/camunda/camunda-process-test-coverage.git cd camunda-process-test-coverage/ mvn clean install Creating Pull Requests # We use pull requests for feature discussion and bug fixes. If you are not yet familiar on how to create a pull request, read this great guide . Some things that make it easier for us to accept your pull requests: Changed code is not reformatted Use four tabs instead of spaces for whitespace The code is tested. Add test cases for the problem you are solving. The mvn clean install build passes including tests The work is combined into a single commit We'd be glad to assist you if you do not get these things right in the first place.","title":"Contributing"},{"location":"developer-guide/contribution.html#how-to-contribute","text":"We'd love you to contribute to this project by filing bugs, helping others on the issue tracker , and by contributing features/bug fixes through pull requests. Read more on how to get the project up and running .","title":"How to Contribute"},{"location":"developer-guide/contribution.html#creating-issues","text":"Please use our issue tracker for project communication. When using the issue tracker: Be descriptive when creating an issue (what, where, when and how does a problem pop up)? Attach steps to reproduce (if applicable) Attach code samples, configuration options or stack traces that may indicate a problem Be helpful and respect others when commenting Create a pull request if you would like to have an in-depth discussion about some piece of code.","title":"Creating Issues"},{"location":"developer-guide/contribution.html#setting-up-the-project-locally","text":"The project is build using Maven 3 as build tool. To build the project by yourself, go to your cmd line and enter mvn clean install on the root of the checked out project. git clone https://github.com/camunda/camunda-process-test-coverage.git cd camunda-process-test-coverage/ mvn clean install","title":"Setting Up the Project Locally"},{"location":"developer-guide/contribution.html#creating-pull-requests","text":"We use pull requests for feature discussion and bug fixes. If you are not yet familiar on how to create a pull request, read this great guide . Some things that make it easier for us to accept your pull requests: Changed code is not reformatted Use four tabs instead of spaces for whitespace The code is tested. Add test cases for the problem you are solving. The mvn clean install build passes including tests The work is combined into a single commit We'd be glad to assist you if you do not get these things right in the first place.","title":"Creating Pull Requests"},{"location":"developer-guide/project-setup.html","text":"If you are interested in developing and building the project please read the following the instructions carefully. Version control # To get sources of the project, please execute: git clone https://github.com/camunda-communit-hub/camunda-rest-client-spring-boot.git cd camunda-rest-client-spring-boot We are using gitflow in our git SCM for naming b## Support Matrixranches. That means that you should start from develop branch, create a feature/<name> out of it and once it is completed create a pull request containing it. Please squash your commits before submitting and use semantic commit messages, if possible. Project Build # Perform the following steps to get a development setup up and running. ./mvnw clean install Integration Tests # By default, the build command will ignore the run of failsafe Maven plugin executing the integration tests (usual JUnit tests with class names ending with ITest). In order to run integration tests, please call from your command line: ./mvnw -Pitest Project build modes and profiles # Camunda Version # You can choose the used Camunda version by specifying the profile camunda-ee or camunda-ce . The default version is a Community Edition. Specify -Pcamunda-ee to switch to Camunda Enterprise edition. This will require a valid Camunda license. You can put it into a file ~/.camunda/license.txt and it will be detected automatically. Documentation # We are using MkDocs for generation of a static site documentation and rely on markdown as much as possible. Note If you want to develop your docs in 'live' mode, run mkdocs serve and access the http://localhost:8000/ from your browser. For creation of documentation, please run: Generation of JavaDoc and Sources # By default, the sources and javadoc API documentation are not generated from the source code. To enable this: ./mvnw clean install -Prelease -Dgpg.skip = true Starting example applications # To start applications, either use your IDE and create run configuration for the class: org.camunda.bpm.extension.rest.example.standalone.CamundaRestClientExampleApplication org.camunda.bpm.extension.rest.example.processapplication.CamundaRestClientExampleApplicationWithEngineProvided Alternatively, you can run them from the command line: ./mvn spring-boot:run -f examples/example ./mvn spring-boot:run -f examples/example-provided Continuous Integration # Github Actions are building all branches on commit hook (for codecov). In addition, a Github Actions are used to build PRs and all branches. Release Management # The release is produced by using the github feature to \"Publish a Release\". What modules get deployed to repository # Every Maven module is enabled by default. If you want to change this, please provide the property <maven.deploy.skip> true </maven.deploy.skip> inside the corresponding pom.xml . Currently, all examples are EXCLUDED from publication into Maven Central.","title":"Project Setup"},{"location":"developer-guide/project-setup.html#version-control","text":"To get sources of the project, please execute: git clone https://github.com/camunda-communit-hub/camunda-rest-client-spring-boot.git cd camunda-rest-client-spring-boot We are using gitflow in our git SCM for naming b## Support Matrixranches. That means that you should start from develop branch, create a feature/<name> out of it and once it is completed create a pull request containing it. Please squash your commits before submitting and use semantic commit messages, if possible.","title":"Version control"},{"location":"developer-guide/project-setup.html#project-build","text":"Perform the following steps to get a development setup up and running. ./mvnw clean install","title":"Project Build"},{"location":"developer-guide/project-setup.html#integration-tests","text":"By default, the build command will ignore the run of failsafe Maven plugin executing the integration tests (usual JUnit tests with class names ending with ITest). In order to run integration tests, please call from your command line: ./mvnw -Pitest","title":"Integration Tests"},{"location":"developer-guide/project-setup.html#project-build-modes-and-profiles","text":"","title":"Project build modes and profiles"},{"location":"developer-guide/project-setup.html#camunda-version","text":"You can choose the used Camunda version by specifying the profile camunda-ee or camunda-ce . The default version is a Community Edition. Specify -Pcamunda-ee to switch to Camunda Enterprise edition. This will require a valid Camunda license. You can put it into a file ~/.camunda/license.txt and it will be detected automatically.","title":"Camunda Version"},{"location":"developer-guide/project-setup.html#documentation","text":"We are using MkDocs for generation of a static site documentation and rely on markdown as much as possible. Note If you want to develop your docs in 'live' mode, run mkdocs serve and access the http://localhost:8000/ from your browser. For creation of documentation, please run:","title":"Documentation"},{"location":"developer-guide/project-setup.html#generation-of-javadoc-and-sources","text":"By default, the sources and javadoc API documentation are not generated from the source code. To enable this: ./mvnw clean install -Prelease -Dgpg.skip = true","title":"Generation of JavaDoc and Sources"},{"location":"developer-guide/project-setup.html#starting-example-applications","text":"To start applications, either use your IDE and create run configuration for the class: org.camunda.bpm.extension.rest.example.standalone.CamundaRestClientExampleApplication org.camunda.bpm.extension.rest.example.processapplication.CamundaRestClientExampleApplicationWithEngineProvided Alternatively, you can run them from the command line: ./mvn spring-boot:run -f examples/example ./mvn spring-boot:run -f examples/example-provided","title":"Starting example applications"},{"location":"developer-guide/project-setup.html#continuous-integration","text":"Github Actions are building all branches on commit hook (for codecov). In addition, a Github Actions are used to build PRs and all branches.","title":"Continuous Integration"},{"location":"developer-guide/project-setup.html#release-management","text":"The release is produced by using the github feature to \"Publish a Release\".","title":"Release Management"},{"location":"developer-guide/project-setup.html#what-modules-get-deployed-to-repository","text":"Every Maven module is enabled by default. If you want to change this, please provide the property <maven.deploy.skip> true </maven.deploy.skip> inside the corresponding pom.xml . Currently, all examples are EXCLUDED from publication into Maven Central.","title":"What modules get deployed to repository"},{"location":"user-guide/index.html","text":"The user guide consists of several sections. Configuration # Configure report directory","title":"Overview"},{"location":"user-guide/index.html#configuration","text":"Configure report directory","title":"Configuration"},{"location":"user-guide/configuration.html","text":"Setup reporting directory # Optionally, you might configure output path for reports. By default the reports are written to ./target/process-test-coverage/ . To change it you can set the system property camunda-process-test-coverage.target-dir-root . Maven # <plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-surefire-plugin </artifactId> <version> 2.22.2 </version> <configuration> <systemPropertyVariables> <camunda-process-test-coverage.target-dir-root> ${project.build.directory}/my-coverage-reports/ </camunda-process-test-coverage.target-dir-root> </systemPropertyVariables> </configuration> </plugin> Gradle (KTS) # tasks { withType < Test > { systemProperties = mapOf ( \"camunda-process-test-coverage.target-dir-root\" to \" $ buildDir /my-coverage-reports/\" ) } }","title":"Configuration"},{"location":"user-guide/configuration.html#setup-reporting-directory","text":"Optionally, you might configure output path for reports. By default the reports are written to ./target/process-test-coverage/ . To change it you can set the system property camunda-process-test-coverage.target-dir-root .","title":"Setup reporting directory"},{"location":"user-guide/configuration.html#maven","text":"<plugin> <groupId> org.apache.maven.plugins </groupId> <artifactId> maven-surefire-plugin </artifactId> <version> 2.22.2 </version> <configuration> <systemPropertyVariables> <camunda-process-test-coverage.target-dir-root> ${project.build.directory}/my-coverage-reports/ </camunda-process-test-coverage.target-dir-root> </systemPropertyVariables> </configuration> </plugin>","title":"Maven"},{"location":"user-guide/configuration.html#gradle-kts","text":"tasks { withType < Test > { systemProperties = mapOf ( \"camunda-process-test-coverage.target-dir-root\" to \" $ buildDir /my-coverage-reports/\" ) } }","title":"Gradle (KTS)"}]}